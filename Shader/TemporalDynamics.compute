// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CalculateActivations
#pragma kernel SpreadActivations
#pragma kernel ClearActivations


struct Phosphene
{
  float2 position;
  float size;
  float2 activation;
  float2 trace;
};

uint2 resolution;
uint2 screenResolution;
int gazeAssistedSampling;
float2 _EyePositionLeft;
float2 _EyePositionRight;
float2 _LeftEyeCenter;
float2 _RightEyeCenter;

float input_effect;     // The factor by which stimulation accumulates to phosphene activation
float intensity_decay;  // The factor by which previous activation still influences current activation
float trace_increase;   // The habituation strength: the factor by which stimulation leads to buildup of memory trace
float trace_decay;      // The factor by which the stimulation memory trace decreases

RWStructuredBuffer<Phosphene> phosphenes;
RWStructuredBuffer<float> pixelLuminance;

RWTexture2DArray<float4> ActivationMask;
RWTexture2DArray<float4> PhospheneTexture;
RWTexture2DArray<float4> PhospheneRender;

[numthreads(32,1,2)]
void CalculateActivations (uint3 id : SV_DispatchThreadID)
{
  Phosphene phosphene = phosphenes[id.x];

  // if gaze assist is set to 1 (on), adjust sample position to eye position
  float2 eyePos = lerp(_EyePositionLeft, _EyePositionRight, id.z);
  float2 eyeCenter = lerp(_LeftEyeCenter, _RightEyeCenter, id.z);
  // calculate corrected phosphene position

  // ToDo: makes left eye blank? right eye renders normally tho
  float2 samplePosition = phosphene.position - 0.5
      + (gazeAssistedSampling * eyePos)           // With gaze assisted sampling, center around current eye position
      + ((1 - gazeAssistedSampling) * eyeCenter); // Without center around eye center calculated at the start of the programme

  // Read stimulation value from activation mask
  uint2 index = uint2((uint)(samplePosition.x * resolution.x), (uint)(samplePosition.y * resolution.y));
  float stim = ActivationMask[uint3(index, id.z)].x;
  
  // Compute phosphene activation as function of previous activation and stimulation
  float actv = phosphene.activation[id.z];
  phosphenes[id.x].activation[id.z] = max(0, intensity_decay*actv + input_effect * (stim - phosphene.trace[id.z]));
  phosphenes[id.x].trace[id.z] = trace_decay*phosphene.trace[id.z] + trace_increase * stim;

  // ToDo: adjust for eye offset; .5,.5 on 2D screen needs to be transformed to eye space?
  uint2 idx = uint2((uint)(samplePosition.x * screenResolution.x), (uint)(samplePosition.y * screenResolution.y));
  PhospheneTexture[uint3(idx, id.z)] =  float4(actv, actv, actv, phosphene.size);
}

float Gaussian(float d, float sigma)
{
  float c = 1.0 / (sigma * 2.50662);
  return c * exp( -(d * d) / (2 * sigma * sigma) );
}

#define xThreads 32
#define yThreads 32

[numthreads(xThreads,yThreads,1)]
void SpreadActivations(uint3 id : SV_DispatchThreadID)
{
  // ToDo: Take Eye position into account
  // ToDo: figure out why radius is bonkers (scale wrong?)

  // get activation data from texture storage
  float4 pixelL = PhospheneTexture[uint3(id.xy, 0)];
  float4 pixelR = PhospheneTexture[uint3(id.xy, 1)];
  const float size = pixelR.w;
  const float actvL = pixelL.x;
  const float actvR = pixelR.x;
  // if it's a pixel without activation or radius, we are done
  if (size < 0.001) { return; }

  PhospheneRender[uint3(id.xy, 0)] = float4(actvL, actvL, actvL, 1);
  PhospheneRender[uint3(id.xy, 1)] = float4(actvR, actvR, actvR, 1);
  
  const float scale = Gaussian(0, size);
  const float size_scale = 10;

  const uint max_r = size * screenResolution.x / size_scale;
  const uint maxr2 = max_r * max_r;
  
  for (uint xOff=0; xOff < max_r; xOff++)
  {
    for (uint yOff=0; yOff < max_r; yOff++)
    {
      // don't overwrite centre
      if (xOff + yOff == 0)
        continue;
      // if we are past radius, move to next x-location
      if ((yOff*yOff + xOff*xOff) >= maxr2)
        break;

      // calculate spread according to gaussian
      float dist = sqrt( (xOff*xOff) / (screenResolution.x * screenResolution.x)
        + (yOff*yOff) / (screenResolution.y * screenResolution.y) );

      // spread left eye
      float spread = actvL * Gaussian(dist, size) / scale;
      PhospheneRender[uint3(id.x + xOff, id.y + yOff, 0)] = float4(spread, spread, 0, 0);
      PhospheneRender[uint3(id.x - xOff, id.y + yOff, 0)] = float4(spread, spread, 0, 0);
      PhospheneRender[uint3(id.x + xOff, id.y - yOff, 0)] = float4(spread, spread, 0, 0);
      PhospheneRender[uint3(id.x - xOff, id.y - yOff, 0)] = float4(spread, spread, 0, 0);

      // spread right eye
      spread = actvR * Gaussian(dist, size) / scale;
      PhospheneRender[uint3(id.x + xOff, id.y + yOff, 1)] = float4(spread, spread, 0, 0);
      PhospheneRender[uint3(id.x - xOff, id.y + yOff, 1)] = float4(spread, spread, 0, 0);
      PhospheneRender[uint3(id.x + xOff, id.y - yOff, 1)] = float4(spread, spread, 0, 0);
      PhospheneRender[uint3(id.x - xOff, id.y - yOff, 1)] = float4(spread, spread, 0, 0);
    }
  }
}


[numthreads(xThreads,yThreads,1)]
void ClearActivations(uint3 id : SV_DispatchThreadID)
{
  PhospheneTexture[uint3(id.xy, 0)] = float4(0,0,0,0);
  PhospheneTexture[uint3(id.xy, 1)] = float4(0,0,0,0);
}