// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CalculateActivations
#pragma kernel SpreadActivations
#pragma kernel ClearActivations

struct Phosphene
{
  float2 position;
  float size;
  float activation;
  float trace;
};

uint2 resolution;
uint2 screenResolution;
int gazeAssistedSampling;
float2 eyePosL;
float2 eyePosR;
float stim;

float2 samplePosition;

float input_effect;     // The factor by which stimulation accumulates to phosphene activation
float intensity_decay;  // The factor by which previous activation still influences current activation
float trace_increase;   // The habituation strength: the factor by which stimulation leads to buildup of memory trace
float trace_decay;      // The factor by which the stimulation memory trace decreases

RWStructuredBuffer<Phosphene> phosphenes;
RWStructuredBuffer<float> pixelLuminance;

RWTexture2D<float4> ActivationMask;
RWTexture2D<float4> PhospheneTexture;
RWTexture2DArray<float4> PhospheneRender;

[numthreads(32,1,2)]
void CalculateActivations (uint3 id : SV_DispatchThreadID)
{
  Phosphene phosphene = phosphenes[id.x];

  // if gaze assist is set to 1 (on), adjust sample position to eye position
  float2 eyePos = lerp(eyePosL, eyePosR, id.z);
  samplePosition = phosphene.position + gazeAssistedSampling * (eyePos - .5);

  // Read stimulation value from activation mask
  uint2 index = uint2((uint)(samplePosition.x * resolution.x), (uint)(samplePosition.y * resolution.y));
  stim = ActivationMask[index.xy].x;
  
  // Compute phosphene activation as function of previous activation and stimulation
  phosphene.activation = max(0, intensity_decay*phosphene.activation + input_effect * (stim - phosphene.trace));
  phosphene.trace = trace_decay*phosphene.trace + trace_increase * stim;

  phosphenes[id.x] = phosphene;

  // ToDo: adjust for eye offset; .5,.5 on 2D screen needs to be transformed to eye space?
  uint2 idx = uint2((uint)(samplePosition.x * screenResolution.x), (uint)(samplePosition.y * screenResolution.x));
  PhospheneTexture[idx.xy] =  float4(phosphene.activation, phosphene.activation, phosphene.activation, phosphene.size);
}

float Gaussian(float d, float sigma)
{
  float c = 1.0 / (sigma * 2.50662);
  return c * exp( -(d * d) / (2 * sigma * sigma) );
}

#define xThreads 32
#define yThreads 32

[numthreads(xThreads,yThreads,1)]
void SpreadActivations(uint3 id : SV_DispatchThreadID)
{
  // ToDo: Take Eye position into account
  // ToDo: figure out why radius is bonkers (scale wrong?)
  float4 pixelVal = PhospheneTexture[id.xy];
  const float size = pixelVal.w;
  if (size < 0.01) { return; }

  uint3 idx = uint3(id.x, id.y, 0);
  PhospheneRender[idx] = float4(pixelVal.x, pixelVal.y, pixelVal.z, 1);
  idx.z = 1;
  PhospheneRender[idx] = float4(pixelVal.x, pixelVal.y, pixelVal.z, 1);
  return;
  const float scale = Gaussian(0, size);

  const uint maxr = size * screenResolution.x / 10;
  const uint maxr2 = maxr * maxr;

  const uint resX2 = screenResolution.x * screenResolution.x;
  
  for (uint xOff=0; xOff < maxr; xOff++)
  {
    for (uint yOff=0; yOff < maxr; yOff++)
    {
      const uint rOff2 = yOff*yOff + xOff*xOff;
      if (rOff2 < maxr2)
      {
        float spread = Gaussian(sqrt(rOff2 / resX2), size) / scale;
        
        idx = uint3(id.x + xOff, id.y + yOff, 0);
        PhospheneRender[idx] += float4(spread, spread, spread, 0);
        idx.z = 1;
        PhospheneRender[idx] += float4(spread, spread, spread, 0);

        idx = uint3(id.x + xOff, id.y - yOff, 0);
        PhospheneRender[idx] += float4(spread, spread, spread, 0);
        idx.z = 1;
        PhospheneRender[idx] += float4(spread, spread, spread, 0);

        idx = uint3(id.x - xOff, id.y + yOff, 0);
        PhospheneRender[idx] += float4(spread, spread, spread, 0);
        idx.z = 1;
        PhospheneRender[idx] += float4(spread, spread, spread, 0);

        idx = uint3(id.x - xOff, id.y - yOff, 0);
        PhospheneRender[idx] += float4(spread, spread, spread, 0);
        idx.z = 1;
        PhospheneRender[idx] += float4(spread, spread, spread, 0);
      }
    }
  }
}


[numthreads(xThreads,yThreads,1)]
void ClearActivations(uint3 id : SV_DispatchThreadID)
{
  uint3 idx = uint3(id.x, id.y, 0);
  PhospheneTexture[idx.xy] = float4(0,0,0,0);
  PhospheneRender[idx] = float4(0,0,0,1);
  idx.z = 1;
  PhospheneRender[idx] = float4(0,0,0,1);
}